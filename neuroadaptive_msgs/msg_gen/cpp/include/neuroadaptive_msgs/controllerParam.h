/* Auto-generated by genmsg_cpp for file /home/isura/groovy_workspace/sandbox/uta_pr2/neuroadaptive_msgs/msg/controllerParam.msg */
#ifndef NEUROADAPTIVE_MSGS_MESSAGE_CONTROLLERPARAM_H
#define NEUROADAPTIVE_MSGS_MESSAGE_CONTROLLERPARAM_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "std_msgs/Header.h"

namespace neuroadaptive_msgs
{
template <class ContainerAllocator>
struct controllerParam_ {
  typedef controllerParam_<ContainerAllocator> Type;

  controllerParam_()
  : header()
  , kappa(0.0)
  , Kv(0.0)
  , lambda(0.0)
  , Kz(0.0)
  , Zb(0.0)
  , F(0.0)
  , G(0.0)
  , inParams(0)
  , outParams(0)
  , hiddenNodes(0)
  , errorParams(0)
  , feedForwardForce(0.0)
  , nn_ON(0.0)
  , cartPos_Kp_x(0.0)
  , cartPos_Kp_y(0.0)
  , cartPos_Kp_z(0.0)
  , cartPos_Kd_x(0.0)
  , cartPos_Kd_y(0.0)
  , cartPos_Kd_z(0.0)
  , cartRot_Kp_x(0.0)
  , cartRot_Kp_y(0.0)
  , cartRot_Kp_z(0.0)
  , cartRot_Kd_x(0.0)
  , cartRot_Kd_y(0.0)
  , cartRot_Kd_z(0.0)
  , useCurrentCartPose(false)
  , useNullspacePose(false)
  , cartIniX(0.0)
  , cartIniY(0.0)
  , cartIniZ(0.0)
  , cartIniRoll(0.0)
  , cartIniPitch(0.0)
  , cartIniYaw(0.0)
  , cartDesX(0.0)
  , cartDesY(0.0)
  , cartDesZ(0.0)
  , cartDesRoll(0.0)
  , cartDesPitch(0.0)
  , cartDesYaw(0.0)
  , m(0.0)
  , d(0.0)
  , k(0.0)
  , task_mA(0.0)
  , task_mB(0.0)
  {
  }

  controllerParam_(const ContainerAllocator& _alloc)
  : header(_alloc)
  , kappa(0.0)
  , Kv(0.0)
  , lambda(0.0)
  , Kz(0.0)
  , Zb(0.0)
  , F(0.0)
  , G(0.0)
  , inParams(0)
  , outParams(0)
  , hiddenNodes(0)
  , errorParams(0)
  , feedForwardForce(0.0)
  , nn_ON(0.0)
  , cartPos_Kp_x(0.0)
  , cartPos_Kp_y(0.0)
  , cartPos_Kp_z(0.0)
  , cartPos_Kd_x(0.0)
  , cartPos_Kd_y(0.0)
  , cartPos_Kd_z(0.0)
  , cartRot_Kp_x(0.0)
  , cartRot_Kp_y(0.0)
  , cartRot_Kp_z(0.0)
  , cartRot_Kd_x(0.0)
  , cartRot_Kd_y(0.0)
  , cartRot_Kd_z(0.0)
  , useCurrentCartPose(false)
  , useNullspacePose(false)
  , cartIniX(0.0)
  , cartIniY(0.0)
  , cartIniZ(0.0)
  , cartIniRoll(0.0)
  , cartIniPitch(0.0)
  , cartIniYaw(0.0)
  , cartDesX(0.0)
  , cartDesY(0.0)
  , cartDesZ(0.0)
  , cartDesRoll(0.0)
  , cartDesPitch(0.0)
  , cartDesYaw(0.0)
  , m(0.0)
  , d(0.0)
  , k(0.0)
  , task_mA(0.0)
  , task_mB(0.0)
  {
  }

  typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
   ::std_msgs::Header_<ContainerAllocator>  header;

  typedef double _kappa_type;
  double kappa;

  typedef double _Kv_type;
  double Kv;

  typedef double _lambda_type;
  double lambda;

  typedef double _Kz_type;
  double Kz;

  typedef double _Zb_type;
  double Zb;

  typedef double _F_type;
  double F;

  typedef double _G_type;
  double G;

  typedef int64_t _inParams_type;
  int64_t inParams;

  typedef int64_t _outParams_type;
  int64_t outParams;

  typedef int64_t _hiddenNodes_type;
  int64_t hiddenNodes;

  typedef int64_t _errorParams_type;
  int64_t errorParams;

  typedef double _feedForwardForce_type;
  double feedForwardForce;

  typedef double _nn_ON_type;
  double nn_ON;

  typedef double _cartPos_Kp_x_type;
  double cartPos_Kp_x;

  typedef double _cartPos_Kp_y_type;
  double cartPos_Kp_y;

  typedef double _cartPos_Kp_z_type;
  double cartPos_Kp_z;

  typedef double _cartPos_Kd_x_type;
  double cartPos_Kd_x;

  typedef double _cartPos_Kd_y_type;
  double cartPos_Kd_y;

  typedef double _cartPos_Kd_z_type;
  double cartPos_Kd_z;

  typedef double _cartRot_Kp_x_type;
  double cartRot_Kp_x;

  typedef double _cartRot_Kp_y_type;
  double cartRot_Kp_y;

  typedef double _cartRot_Kp_z_type;
  double cartRot_Kp_z;

  typedef double _cartRot_Kd_x_type;
  double cartRot_Kd_x;

  typedef double _cartRot_Kd_y_type;
  double cartRot_Kd_y;

  typedef double _cartRot_Kd_z_type;
  double cartRot_Kd_z;

  typedef uint8_t _useCurrentCartPose_type;
  uint8_t useCurrentCartPose;

  typedef uint8_t _useNullspacePose_type;
  uint8_t useNullspacePose;

  typedef double _cartIniX_type;
  double cartIniX;

  typedef double _cartIniY_type;
  double cartIniY;

  typedef double _cartIniZ_type;
  double cartIniZ;

  typedef double _cartIniRoll_type;
  double cartIniRoll;

  typedef double _cartIniPitch_type;
  double cartIniPitch;

  typedef double _cartIniYaw_type;
  double cartIniYaw;

  typedef double _cartDesX_type;
  double cartDesX;

  typedef double _cartDesY_type;
  double cartDesY;

  typedef double _cartDesZ_type;
  double cartDesZ;

  typedef double _cartDesRoll_type;
  double cartDesRoll;

  typedef double _cartDesPitch_type;
  double cartDesPitch;

  typedef double _cartDesYaw_type;
  double cartDesYaw;

  typedef double _m_type;
  double m;

  typedef double _d_type;
  double d;

  typedef double _k_type;
  double k;

  typedef double _task_mA_type;
  double task_mA;

  typedef double _task_mB_type;
  double task_mB;


  typedef boost::shared_ptr< ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::neuroadaptive_msgs::controllerParam_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct controllerParam
typedef  ::neuroadaptive_msgs::controllerParam_<std::allocator<void> > controllerParam;

typedef boost::shared_ptr< ::neuroadaptive_msgs::controllerParam> controllerParamPtr;
typedef boost::shared_ptr< ::neuroadaptive_msgs::controllerParam const> controllerParamConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace neuroadaptive_msgs

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::neuroadaptive_msgs::controllerParam_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> > {
  static const char* value() 
  {
    return "af3621078a88b07f1ac5f3bd11b79f17";
  }

  static const char* value(const  ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xaf3621078a88b07fULL;
  static const uint64_t static_value2 = 0x1ac5f3bd11b79f17ULL;
};

template<class ContainerAllocator>
struct DataType< ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> > {
  static const char* value() 
  {
    return "neuroadaptive_msgs/controllerParam";
  }

  static const char* value(const  ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> > {
  static const char* value() 
  {
    return "Header header\n\
\n\
# NN Params\n\
float64 kappa\n\
float64 Kv\n\
float64 lambda\n\
float64 Kz\n\
float64 Zb\n\
float64 F\n\
float64 G\n\
int64 inParams\n\
int64 outParams\n\
int64 hiddenNodes\n\
int64 errorParams\n\
float64 feedForwardForce\n\
float64 nn_ON\n\
\n\
# Cart params\n\
float64 cartPos_Kp_x\n\
float64 cartPos_Kp_y\n\
float64 cartPos_Kp_z\n\
float64 cartPos_Kd_x\n\
float64 cartPos_Kd_y\n\
float64 cartPos_Kd_z\n\
\n\
float64 cartRot_Kp_x\n\
float64 cartRot_Kp_y\n\
float64 cartRot_Kp_z\n\
float64 cartRot_Kd_x\n\
float64 cartRot_Kd_y\n\
float64 cartRot_Kd_z\n\
\n\
bool useCurrentCartPose\n\
bool useNullspacePose\n\
\n\
float64 cartIniX    \n\
float64 cartIniY    \n\
float64 cartIniZ\n\
float64 cartIniRoll \n\
float64 cartIniPitch\n\
float64 cartIniYaw  \n\
\n\
float64 cartDesX    \n\
float64 cartDesY    \n\
float64 cartDesZ    \n\
float64 cartDesRoll \n\
float64 cartDesPitch\n\
float64 cartDesYaw  \n\
\n\
# Ref Model Params\n\
float64 m\n\
float64 d\n\
float64 k\n\
\n\
float64 task_mA\n\
float64 task_mB\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.secs: seconds (stamp_secs) since epoch\n\
# * stamp.nsecs: nanoseconds since stamp_secs\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
";
  }

  static const char* value(const  ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct HasHeader< ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct HasHeader< const ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.header);
    stream.next(m.kappa);
    stream.next(m.Kv);
    stream.next(m.lambda);
    stream.next(m.Kz);
    stream.next(m.Zb);
    stream.next(m.F);
    stream.next(m.G);
    stream.next(m.inParams);
    stream.next(m.outParams);
    stream.next(m.hiddenNodes);
    stream.next(m.errorParams);
    stream.next(m.feedForwardForce);
    stream.next(m.nn_ON);
    stream.next(m.cartPos_Kp_x);
    stream.next(m.cartPos_Kp_y);
    stream.next(m.cartPos_Kp_z);
    stream.next(m.cartPos_Kd_x);
    stream.next(m.cartPos_Kd_y);
    stream.next(m.cartPos_Kd_z);
    stream.next(m.cartRot_Kp_x);
    stream.next(m.cartRot_Kp_y);
    stream.next(m.cartRot_Kp_z);
    stream.next(m.cartRot_Kd_x);
    stream.next(m.cartRot_Kd_y);
    stream.next(m.cartRot_Kd_z);
    stream.next(m.useCurrentCartPose);
    stream.next(m.useNullspacePose);
    stream.next(m.cartIniX);
    stream.next(m.cartIniY);
    stream.next(m.cartIniZ);
    stream.next(m.cartIniRoll);
    stream.next(m.cartIniPitch);
    stream.next(m.cartIniYaw);
    stream.next(m.cartDesX);
    stream.next(m.cartDesY);
    stream.next(m.cartDesZ);
    stream.next(m.cartDesRoll);
    stream.next(m.cartDesPitch);
    stream.next(m.cartDesYaw);
    stream.next(m.m);
    stream.next(m.d);
    stream.next(m.k);
    stream.next(m.task_mA);
    stream.next(m.task_mB);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct controllerParam_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::neuroadaptive_msgs::controllerParam_<ContainerAllocator> & v) 
  {
    s << indent << "header: ";
s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "kappa: ";
    Printer<double>::stream(s, indent + "  ", v.kappa);
    s << indent << "Kv: ";
    Printer<double>::stream(s, indent + "  ", v.Kv);
    s << indent << "lambda: ";
    Printer<double>::stream(s, indent + "  ", v.lambda);
    s << indent << "Kz: ";
    Printer<double>::stream(s, indent + "  ", v.Kz);
    s << indent << "Zb: ";
    Printer<double>::stream(s, indent + "  ", v.Zb);
    s << indent << "F: ";
    Printer<double>::stream(s, indent + "  ", v.F);
    s << indent << "G: ";
    Printer<double>::stream(s, indent + "  ", v.G);
    s << indent << "inParams: ";
    Printer<int64_t>::stream(s, indent + "  ", v.inParams);
    s << indent << "outParams: ";
    Printer<int64_t>::stream(s, indent + "  ", v.outParams);
    s << indent << "hiddenNodes: ";
    Printer<int64_t>::stream(s, indent + "  ", v.hiddenNodes);
    s << indent << "errorParams: ";
    Printer<int64_t>::stream(s, indent + "  ", v.errorParams);
    s << indent << "feedForwardForce: ";
    Printer<double>::stream(s, indent + "  ", v.feedForwardForce);
    s << indent << "nn_ON: ";
    Printer<double>::stream(s, indent + "  ", v.nn_ON);
    s << indent << "cartPos_Kp_x: ";
    Printer<double>::stream(s, indent + "  ", v.cartPos_Kp_x);
    s << indent << "cartPos_Kp_y: ";
    Printer<double>::stream(s, indent + "  ", v.cartPos_Kp_y);
    s << indent << "cartPos_Kp_z: ";
    Printer<double>::stream(s, indent + "  ", v.cartPos_Kp_z);
    s << indent << "cartPos_Kd_x: ";
    Printer<double>::stream(s, indent + "  ", v.cartPos_Kd_x);
    s << indent << "cartPos_Kd_y: ";
    Printer<double>::stream(s, indent + "  ", v.cartPos_Kd_y);
    s << indent << "cartPos_Kd_z: ";
    Printer<double>::stream(s, indent + "  ", v.cartPos_Kd_z);
    s << indent << "cartRot_Kp_x: ";
    Printer<double>::stream(s, indent + "  ", v.cartRot_Kp_x);
    s << indent << "cartRot_Kp_y: ";
    Printer<double>::stream(s, indent + "  ", v.cartRot_Kp_y);
    s << indent << "cartRot_Kp_z: ";
    Printer<double>::stream(s, indent + "  ", v.cartRot_Kp_z);
    s << indent << "cartRot_Kd_x: ";
    Printer<double>::stream(s, indent + "  ", v.cartRot_Kd_x);
    s << indent << "cartRot_Kd_y: ";
    Printer<double>::stream(s, indent + "  ", v.cartRot_Kd_y);
    s << indent << "cartRot_Kd_z: ";
    Printer<double>::stream(s, indent + "  ", v.cartRot_Kd_z);
    s << indent << "useCurrentCartPose: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.useCurrentCartPose);
    s << indent << "useNullspacePose: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.useNullspacePose);
    s << indent << "cartIniX: ";
    Printer<double>::stream(s, indent + "  ", v.cartIniX);
    s << indent << "cartIniY: ";
    Printer<double>::stream(s, indent + "  ", v.cartIniY);
    s << indent << "cartIniZ: ";
    Printer<double>::stream(s, indent + "  ", v.cartIniZ);
    s << indent << "cartIniRoll: ";
    Printer<double>::stream(s, indent + "  ", v.cartIniRoll);
    s << indent << "cartIniPitch: ";
    Printer<double>::stream(s, indent + "  ", v.cartIniPitch);
    s << indent << "cartIniYaw: ";
    Printer<double>::stream(s, indent + "  ", v.cartIniYaw);
    s << indent << "cartDesX: ";
    Printer<double>::stream(s, indent + "  ", v.cartDesX);
    s << indent << "cartDesY: ";
    Printer<double>::stream(s, indent + "  ", v.cartDesY);
    s << indent << "cartDesZ: ";
    Printer<double>::stream(s, indent + "  ", v.cartDesZ);
    s << indent << "cartDesRoll: ";
    Printer<double>::stream(s, indent + "  ", v.cartDesRoll);
    s << indent << "cartDesPitch: ";
    Printer<double>::stream(s, indent + "  ", v.cartDesPitch);
    s << indent << "cartDesYaw: ";
    Printer<double>::stream(s, indent + "  ", v.cartDesYaw);
    s << indent << "m: ";
    Printer<double>::stream(s, indent + "  ", v.m);
    s << indent << "d: ";
    Printer<double>::stream(s, indent + "  ", v.d);
    s << indent << "k: ";
    Printer<double>::stream(s, indent + "  ", v.k);
    s << indent << "task_mA: ";
    Printer<double>::stream(s, indent + "  ", v.task_mA);
    s << indent << "task_mB: ";
    Printer<double>::stream(s, indent + "  ", v.task_mB);
  }
};


} // namespace message_operations
} // namespace ros

#endif // NEUROADAPTIVE_MSGS_MESSAGE_CONTROLLERPARAM_H

