/* Auto-generated by genmsg_cpp for file /home/isura/groovy_workspace/sandbox/uta_pr2/neuroadaptive_msgs/srv/controllerParamUpdate.srv */
#ifndef NEUROADAPTIVE_MSGS_SERVICE_CONTROLLERPARAMUPDATE_H
#define NEUROADAPTIVE_MSGS_SERVICE_CONTROLLERPARAMUPDATE_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "ros/service_traits.h"

#include "neuroadaptive_msgs/controllerParam.h"



namespace neuroadaptive_msgs
{
template <class ContainerAllocator>
struct controllerParamUpdateRequest_ {
  typedef controllerParamUpdateRequest_<ContainerAllocator> Type;

  controllerParamUpdateRequest_()
  : msg()
  {
  }

  controllerParamUpdateRequest_(const ContainerAllocator& _alloc)
  : msg(_alloc)
  {
  }

  typedef  ::neuroadaptive_msgs::controllerParam_<ContainerAllocator>  _msg_type;
   ::neuroadaptive_msgs::controllerParam_<ContainerAllocator>  msg;


  typedef boost::shared_ptr< ::neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct controllerParamUpdateRequest
typedef  ::neuroadaptive_msgs::controllerParamUpdateRequest_<std::allocator<void> > controllerParamUpdateRequest;

typedef boost::shared_ptr< ::neuroadaptive_msgs::controllerParamUpdateRequest> controllerParamUpdateRequestPtr;
typedef boost::shared_ptr< ::neuroadaptive_msgs::controllerParamUpdateRequest const> controllerParamUpdateRequestConstPtr;



template <class ContainerAllocator>
struct controllerParamUpdateResponse_ {
  typedef controllerParamUpdateResponse_<ContainerAllocator> Type;

  controllerParamUpdateResponse_()
  : success(false)
  {
  }

  controllerParamUpdateResponse_(const ContainerAllocator& _alloc)
  : success(false)
  {
  }

  typedef uint8_t _success_type;
  uint8_t success;


  typedef boost::shared_ptr< ::neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct controllerParamUpdateResponse
typedef  ::neuroadaptive_msgs::controllerParamUpdateResponse_<std::allocator<void> > controllerParamUpdateResponse;

typedef boost::shared_ptr< ::neuroadaptive_msgs::controllerParamUpdateResponse> controllerParamUpdateResponsePtr;
typedef boost::shared_ptr< ::neuroadaptive_msgs::controllerParamUpdateResponse const> controllerParamUpdateResponseConstPtr;


struct controllerParamUpdate
{

typedef controllerParamUpdateRequest Request;
typedef controllerParamUpdateResponse Response;
Request request;
Response response;

typedef Request RequestType;
typedef Response ResponseType;
}; // struct controllerParamUpdate
} // namespace neuroadaptive_msgs

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "bfb20bf2c229fc41911de76270e14569";
  }

  static const char* value(const  ::neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xbfb20bf2c229fc41ULL;
  static const uint64_t static_value2 = 0x911de76270e14569ULL;
};

template<class ContainerAllocator>
struct DataType< ::neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "neuroadaptive_msgs/controllerParamUpdateRequest";
  }

  static const char* value(const  ::neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "\n\
controllerParam msg\n\
\n\
================================================================================\n\
MSG: neuroadaptive_msgs/controllerParam\n\
Header header\n\
\n\
# NN Params\n\
float64 kappa\n\
float64 Kv\n\
float64 lambda\n\
float64 Kz\n\
float64 Zb\n\
float64 F\n\
float64 G\n\
int64 inParams\n\
int64 outParams\n\
int64 hiddenNodes\n\
int64 errorParams\n\
float64 feedForwardForce\n\
float64 nn_ON\n\
\n\
# Cart params\n\
float64 cartPos_Kp_x\n\
float64 cartPos_Kp_y\n\
float64 cartPos_Kp_z\n\
float64 cartPos_Kd_x\n\
float64 cartPos_Kd_y\n\
float64 cartPos_Kd_z\n\
\n\
float64 cartRot_Kp_x\n\
float64 cartRot_Kp_y\n\
float64 cartRot_Kp_z\n\
float64 cartRot_Kd_x\n\
float64 cartRot_Kd_y\n\
float64 cartRot_Kd_z\n\
\n\
bool useCurrentCartPose\n\
bool useNullspacePose\n\
\n\
float64 cartIniX    \n\
float64 cartIniY    \n\
float64 cartIniZ\n\
float64 cartIniRoll \n\
float64 cartIniPitch\n\
float64 cartIniYaw  \n\
\n\
float64 cartDesX    \n\
float64 cartDesY    \n\
float64 cartDesZ    \n\
float64 cartDesRoll \n\
float64 cartDesPitch\n\
float64 cartDesYaw  \n\
\n\
# Ref Model Params\n\
float64 m\n\
float64 d\n\
float64 k\n\
\n\
float64 task_mA\n\
float64 task_mB\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.secs: seconds (stamp_secs) since epoch\n\
# * stamp.nsecs: nanoseconds since stamp_secs\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
";
  }

  static const char* value(const  ::neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros


namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "358e233cde0c8a8bcfea4ce193f8fc15";
  }

  static const char* value(const  ::neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x358e233cde0c8a8bULL;
  static const uint64_t static_value2 = 0xcfea4ce193f8fc15ULL;
};

template<class ContainerAllocator>
struct DataType< ::neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "neuroadaptive_msgs/controllerParamUpdateResponse";
  }

  static const char* value(const  ::neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "\n\
bool success\n\
\n\
";
  }

  static const char* value(const  ::neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.msg);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct controllerParamUpdateRequest_
} // namespace serialization
} // namespace ros


namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.success);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct controllerParamUpdateResponse_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace service_traits
{
template<>
struct MD5Sum<neuroadaptive_msgs::controllerParamUpdate> {
  static const char* value() 
  {
    return "c95d6edeed3ff05d22a3f8b98eefd5bf";
  }

  static const char* value(const neuroadaptive_msgs::controllerParamUpdate&) { return value(); } 
};

template<>
struct DataType<neuroadaptive_msgs::controllerParamUpdate> {
  static const char* value() 
  {
    return "neuroadaptive_msgs/controllerParamUpdate";
  }

  static const char* value(const neuroadaptive_msgs::controllerParamUpdate&) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "c95d6edeed3ff05d22a3f8b98eefd5bf";
  }

  static const char* value(const neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "neuroadaptive_msgs/controllerParamUpdate";
  }

  static const char* value(const neuroadaptive_msgs::controllerParamUpdateRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "c95d6edeed3ff05d22a3f8b98eefd5bf";
  }

  static const char* value(const neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "neuroadaptive_msgs/controllerParamUpdate";
  }

  static const char* value(const neuroadaptive_msgs::controllerParamUpdateResponse_<ContainerAllocator> &) { return value(); } 
};

} // namespace service_traits
} // namespace ros

#endif // NEUROADAPTIVE_MSGS_SERVICE_CONTROLLERPARAMUPDATE_H

